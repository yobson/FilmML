# Things too long for comments

In here I will be documenting anything too long to put as a comment in the actual code. If you want to view the maths in this, please get [Github mathjax extention](https://chrome.google.com/webstore/detail/github-with-mathjax/ioemnmodlmafdkllaclgeombjnmnbima) and view this document [here](https://github.com/yobson/FilmML/blob/master/ThingsTooLongForTheComments.md).

## SEL and IMP

SEL and IMP are both types in Objective C and I use them quite a lot as a way of optimizing the code. SEL is a pointer to a method selector. I realise that that isn't very helpful so I am including apple's description of it:

```c
typedef struct objc_selector *SEL;
```

> Method selectors are used to represent the name of a method at runtime. A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded.

It is a place to store a message that can be sent to an object.

IMP is a pointer to the space in memory a method really is. As you may or may not know, objective c works by sending messages to objects which respond and return results. The computer doesn't just access a method at a certain point in memory like in C++. Although this is fantastic for many things, it is slower than I would have liked. This is where the IMP type comes in.

```C
id (*IMP)(id, SEL, ...)
```

> This data type is a pointer to the start of the function that implements the method. This function uses standard C calling conventions as implemented for the current CPU architecture. The first argument is a pointer to `self` (that is, the memory for the particular instance of this class, or, for a class method, a pointer to the metaclass). The second argument is the method selector. The method arguments follow.

So by using a SEL and IMP, I can make essentially a pointer to a C function (of return type id). When I call the IMP, it executes without having to faff around funding the code to run. This means if I have a loop that calls a method in an objc object repeatedly, it is far faster to use an IMP and SEL.

## The loops in triggerfullSystemML()

This explains lines 179-199 in main.m

This is the most intensive part of the program and probably needs optimizing massively. It is designed to run and compatibility function for each user and film, find the top n films for each user and add it to the user's suggested film list. This is why a user is killed off after a few days, this is a function $f^u$ complexity. First variables are assigned to make the code more useable and an empty binary is created:

```objective-c
currentUser = (User*)imp_getObject(users, sel_getObject, i);
numberOfUnseenFilms = nextFilmID - (unsigned int)imp_filmNUmber(currentUser, sel_filmNumber);
BTree *tree = NULL;
MLType* userData = (MLType*)imp_getMLDataUser(currentUser, sel_getMLData);
MLType* filmData = (MLType*)imp_getMLDataFilm(filmToTest, sel_getMLData);
```

Next, it cycles through all the films and runs another loop for each. In this loop, we see if the a user has seen the given film, if they haven't we apply the compatibility function to both and add it's ID to a binary tree. By adding it to a binary tree, we don't have to order the list after by compatibility score, it is already ordered. Once this is done, we then call ``` void topN(...); ```. This should get the top N IDs in the binary tree and pop them in an array that is passed by reference to the function. We finally add this to the user's film suggestion list and delete the tree. The next user in the list is then used.

## BinaryTree.m

This is a simple static c library for building binary trees that supports a `float` ranking system and an `unsigned int `  to place an index of a film or user. There is a function to add data into the tree defined like this:

``` c
void addToTree(BTree *tree, float ranking, unsigned int data);
```

It is a recursive function. meaning that you pass in a pointer to the top of the tree and it will call itself over and over again changing where it perceives the top of the tree until it finds somewhere to put your data. The input is defined as follows

- *tree - a reference to the top of the tree
- ranking - this is the float that is used to sort the items in the tree. The position in the tree is determined by this number
- data - in this case, its a stupid variable name for the ID that we are going to store in the tree

Next we have two functions for finding the top n values in our tree. Here are the definitions:

```c
void _TopN(BTree *tree, unsigned int **out);
void topN(unsigned int n, BTree *tree, unsigned int **out);
```

`_TopN` is not a function to be called, designed for internal use only. It is the function that does the work when finding the top n items in a list. It has less arguments because it stores most state in global variables so that different branches of recursive calling can access the newest state information. `topN` is not a recursive function, but simply a function that sets up the global variables for `_TopN` and calls it. 

- n - the number of values to be returned (the highest n values in the tree)
- *tree - a reference tree to use
- **out - a reference to the output array.

Finally, a function that deletes the tree:

```c
void deleteTree(BTree *tree);
```

Pretty self explanatory.

## Common.m

This is a file where common, intensive tasks are placed. By design, although it has a .m extension, only c code is placed in this file. This is to avoid any of it running at a sub-optimal speed.

### Sync Taste Preferences

This is a function that works out the delta vector and applies it to the film and user taste score vectors. It is made up of three main for loops and two sub for loops inside the first and last main for loop. The first for loop is as follows:

```c
for (unsigned int i = 0; i < userCount; i++) {
  uArray = users[i]->tasteScores;
  for (int j = 0; j < numberOfFilmTypes; j++) {
     deltas[j] += (uArray[j] - film->tasteScores[j]) / userCount;
  }
}
```

It iterates through all the users and builds a delta vector. This is made up of the taste scores of a user - the taste score of a film. The input is only for users that have watched a film. It then divides the vector by the number of users because it wants to find an average change for the film. It does this for all users attached to that film. It can be summarized like this 

$$
\vec{\Delta} = \sum^{n}_{i = 1} \frac{\vec{f} - \vec{u}_i}{n}
$$

The next for loop simply applies the delta vector to the film taste score vector using the learning function which can be defined as:

$$
\vec{f}_{t+1} = \vec{f}_{t} + \vec{\Delta} \cdot v \cdot (1-\eta) + \eta \cdot \vec{f}_{t-1} 
$$

where

- $\vec{f}$ is the film taste score vector at a given $t$ point in time
- $\vec{\Delta}$ Is the delta taste score vector
- $v$ is the learning velocity (higher is faster learning, but less accurate)
- $\eta$ is the momentum, how much the previous change influences the next.


The final for loop applies a similar function for the each user (the outer for loop goes though the users, the inner applies the ML function).

### The Compatibility Function

At the moment, it is primitively boring. It can be written like this:

$$
c  =\vec{u} \cdot \vec{f} \cdot n
$$

where

- $c$ is the compatibility score
- $\vec{u}$ is the user taste score vector
- $\vec{f}$ is the film taste score vector
- $n$ is the number of unique views for the given film

However, the plan is to use the number of views in a more spicy way, but this will happen after testing.
